\documentclass[flenqn, 14pt]{extarticle}

\usepackage[14pt]{extsizes}
\usepackage{amssymb}
\usepackage{amsmath}
%%\setlength{\mathindent}{0pt}
\usepackage{stmaryrd}
\usepackage{tabularx}
\usepackage[justification=centering]{caption}

\usepackage{graphicx}
\usepackage{epstopdf}

\usepackage{mathtext} % Русские буквы в формулах
\usepackage{array}

\usepackage{longtable}
\usepackage[left=2cm,right=2cm,
    top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
    
\usepackage{latexsym} %Включает latex пакеты
\usepackage[T2A]{fontenc} %Подключает поддержку кодировок, отличных от латиницы.
\usepackage[utf8]{inputenc} %Указывает, что текст будет вводится в utf8 кодировке.
\usepackage[russian]{babel} %Подключает интернациональный паке babel.
\usepackage{setspace}
\pagestyle{plain} \onehalfspacing

%\usepackage{ccaption}
%\captiondelim{. }

\newcolumntype{L}[1]{>{\hsize=#1\hsize\raggedright\arraybackslash}X}%
\newcolumntype{R}[1]{>{\hsize=#1\hsize\raggedleft\arraybackslash}X}%
\newcolumntype{C}[1]{>{\hsize=#1\hsize\centering\arraybackslash}X}%

\begin{document}
\begin{center}
\section*{Измененный и переоцененный Reduceron (Редуцерон)}
\end{center}
\begin{center}
Мэтью Нейлор (Mettew Naylor) и Колин Рансиман (Colin Runciman) \\
Департамент информатики, Йоркский университет, Йорк, Северный Йоркшир, Великобритания \\
(e-mail: \{mfn,colin\}@cs.york.ac.uk)
\end{center}

\section*{Реферат}
Представлена новая версия специалированного процессора для исполнения ленивых функциональных программ. Этот процессор - Редуцерон - использует параллельную память и динамический анализ для увеличения скорости исполнения и реализован, используя перенастраиваемое аппаратное обеспечение. По сравнению с более традиционными реализациями функционального языка, нацеленные на стандартный RISC процессор, работающий на том же перенастраиваемом аппаратном обеспечении, Редуцерон предлагает существенное улучшение производительности во время выполнения.

\section{Введение}
Эффективное выполнение высокоуровневых функциональных программ на традиционных компьютерах - большой вызов. Необходимы сложные техники для использования архитектурных возможностей, разработанных для низкоуровневой императивной модели исполнения. Более того, традиционные компьютеры имеют ограничения при исполнении функциональных программ. Для примера, ширина канала памяти ограничена последовательным обменом маленькими частями информации. Исполняющие устройства, основанные на редукции графов, производят интенсивные операции по созданию и уничтожению выражений в памяти. Каждая такая операция требует последовательного исполнения множества машинных инструкций, не из-за наличия врожденных зависимостей в данных, а из-за архитектурных решений в традиционных компьютерах.

Все это стимулирует идею компьютеров, специально спроектированных для соответствия нуждам высокоуровневым функциональных языков - примерно как графические ускорители (GPU) созданы для соответствия задачам компьютерной графики. С помощью обеспечения минимального набора возможностей, специально заточенных для исполнения функциональных программ, такой \textit{специализированный компьютер} может быть не только быстрым, но и простым с достоинствами, такими как: более полная верификация и более низкое потребление энергии. Это не новая идея. В 1980х и 1990х проводилась 15-ти летняя серия конференций ACM (\textbf{Association of Computing Machinery} - Ассоциация Вычислительной Техники) - \textit{Функциональные Языки программирования и Компьютерная Архитектура}. Исходя из раздельных инициатив, существовал целый симпозиум занятый только графо-редукционными машинами (Фазель (Fasel) \& Келлер (Keller) 1987), и крупный производитель компьютеров изготовил прототип графо-редукционной машины (Чивел (Scheevel) 1986). Но процесс прозводства нового экзотического аппаратного обеспечения был медленный и неопределенным. Из-за крупных продвижений в компиляции для еще более больших, быстрых и дешевых массовых машин, идея специализированного аппаратного обеспечения для функциональных языков вышла из моды.

\textbf{Реконфигуриемое аппаратное обеспечение.} В наши дни ситуация немного другая. \textit{Программируемая пользователем вентильная матрица} (ППВМ или FPGA) сильно уменьшило усилия и необходимость в экспертизе в разработке специализированного аппаратного обеспечения. FPGA содержит тысячи параллельных логических блоков, которые могут быть настроены по желанию разработчика с помощью программных инструментов. Они широко распространены и представляют из себя развитую технологию сами по себе. 

Недостатоком применения FPGA является то, что они обычно имеют гораздо более низкие максимальные рабочие частоты, чем соответствующие специально разработанные кристаллы - это цена, которую мы платим за перенастраиваемость. Следовательно, для достижения хорошей производительности, используя FPGA, необходимо значительно использовать параллелизм. 

\textbf{Редуцерон.} В данной статье мы представляем специализированную машины для последовательной редукции графа - the Reduceron  (Редуцерон) - реализованный на FPGA. Мы основываемся на нашей предыдущей работе по этой же теме (Нейлор (Naylor) \& Рансиман (Runciman) , 2008) и представляем новый дизайн, который показывает пятикратное улучшение производительности.

Примечательная особенность нашего нового дизайна является то, что каждое из его шести семантических правил редукции производится за один такт. Все необходимые транзакции памяти, необходимые для выполнения редукции, производятся параллельно. Редуцерон производит в среднем 0.55 ручных редукций (hand-reductions) на каждый такт. Ручная редукция - это редукция, которую программист бы производил при \textit{ручном} выполнении трека программы; она включает в себя применения функций и анализ частности (case analysis), но не включает редукции машинного уровня такие как обновление и размотка (unwinding). 

Другая важная разработка в нашем новом дизайне - это использование динамического анализа, позволяющего выполнять \textit{избегание обновления} (update avoidance) и \textit{предсказательное вычисление примитивных выражений} (speculative evaluation of primitive redexes), каждая из которых приводит к значительному улучшению производительности. На традиционных компьютерах накладные расходы во время исполнения такого динамического анализа будут непомерно высокими, но на FPGA он дешевый и простой в реализации.

\textbf{Вклад.} В целом, было сделано следующее: \\
\textbf{Глава 2.} Точное описание компилятора Редуцерона, включая уточнения для кодирования конструкторов по Скотту (Scott encoding of constructors), используемое для компилирования частных выражений (case expressions) и связанное с различными проблемами эффектиности.

\textbf{Глава 3.} Рабочая семантика машины конкретизации шаблонов, лежащая в основе реализации Редуцирона.

\textbf{Глава 4.} Подробное описание как каждое семантическое правило редукции реализовано в один такт, используя FPGA.

\textbf{Глава 5.} Расширения в семантику для поддержки (1) динамического анализа разделяемости, используемого для избегания нежелательных обновлений кучи, и (2) динамическое определение примитивных выражений, позволяющее произвести предсказательную редукцию таких выражений во время конкретизации тела функции. 

\textbf{Глава 6.} Сравнительная оценка реализации Редуцерона с другими реализациями функционального языка.

\textbf{Расширения.} Это статья является расширенной версией статьи для конференции (Нейлор (Naylor) \& Рансимэн (Ranciman), 2010). Главные новые дополнения следующие:
\begin{itemize}
\item Рисунок 2 добавлен для формализации схемы компиляции Редуцерона.
\item Глава 4.3 расширена новыми деталями агоритма разделения шаблонов.
\item Глава 6.1 расширена сравнением Редуцерона с традиционным компилируемой реализации функционального языка, нацеленной на \textit{Компьютер с Сокращенным Набором Комманд} (RISC), работающим на той же FPGA. (Это наиболее значительное новое добавление, отраженное добавление слова "переоцененный" к названию статьи).
\item Глава 6.9 расширена большим количеством деталей начальных экспериментов со статическими предположениями о примитивных выражениях (static primitive-redex speculation (PRS)).
\item Главы 6.10, 6.12, 6.13 и 6.14 добавлены для расширенного обсуждения связанных работ.
\end{itemize}

\begin{figure}[t]
\centering
\includegraphics[scale=0.4]{core_syntax}
\label{fig:core_syntax}
\caption{Синтаксис ядра языка F-lite.}
\end{figure}

\section{Компиляция}
Эта секция определяет набор уточнений, которые приводят программу, написанну на ленивом языке программирования F-lite, к форме, известной как \textit{шаблонный код} (template code), которую Редуцерон может исполнять.

\subsection{Исходный язык}
F-lite является ядровым ленивым функциональным языком, близкий к подмножествам как Haskell так и Clean. Синтаксис F-lite представлен на рис.~\ref{fig:core_syntax}.

\textbf{Частные выражения (case expressions).} Частные выражения представлены в упрощенной форме, которая может быть получена с помощью компилятора шаблонного поиска (pattern match compiler), такого как тот, который определен в Peyton Jones (1987). Шаблоны в частных выражениях являются конструкторами, примененными к нулю или более переменным. Каждое частное выражение содержит альтернативу для каждого конструктора расматриваемого в выражении типа.

\textbf{Примитивы.} Мета-переменная \textit{p} обозначает символ примитивной функции. Все применения примитивных функций полностью насыщены (т.е. они не могут частично применяться, можно подать только столько переменных, сколько арность примитивной функции). Редуцерон реализует только малый набор примитивных операций, не полный набор традиционного процессора, например, отсутствуют операции с числами с плавающей запятой. В примитивы, используемые в данной статье, включаются (+), (-) и (<=).

\textbf{Main.} Каждая программа содержит определение главной функции \textit{main = e}, где e является выражением, которое вычисляется в целочисленное n; результат выполнения программы - значение n.

\textbf{Таблицы частных случаев (Case tables).} Отметим необычную конструкцию для таблиц частных случаев $<\overrightarrow{f}>$. Таблицы частных случаев не пишутся в исходных программах, а появляются во время компиляции - смотри Главу 2.4.

\textbf{Примеры.} Ниже представлены два примера для определения функции. Первая соединяет два списка и вторая высчитывает треугольные числа.

\begin{verbatim}
append xs ys = case xs of
  { Nil -> ys ; Cons x xs -> Cons x (append xs ys) }
  
tri n = case (<=) n 1 of
  { False -> (+) (tri ((-) n 1)) n ; True -> 1 }
\end{verbatim}

\subsection{Терминология}
\textbf{Длина применения (Application length).} \textit{Длина} применения $e_1 \ldots e_n$ есть $n$. Для примера, длина применения \textit{append xs ys} - 3.

\textbf{Смешанные выражения (Compound expression) и атомарные выражения (atomic expressions).} Применения, частные выражения и выражения объявления (let expressions) являются смешанными. Все другие выражения являются атомарными.

\textbf{Плоские выражния (Flat expression).} Плоское выражение - это атомарное выражение или применение $e_1 \ldots e_n$, в котором каждое $e_i$ для $i \in [1 \ldots n]$ является атомарным выражением. Для примера, \textit{append xs ys} является плоским выражением, но \textit{tri ((-) n 1)} не является.

\textbf{Граф выражения (Expression graph).} Выражение объявления:
$$
let \; \{ x_1 = e_1 ; \ldots ; x_n = e_n \} \; in \; e
$$
является графом выражения тогда и только тогда, когда $e$ является плоским выражением и каждое $e_i$ для $i \in [1 \ldots n]$ также является плоским выражением. Графы выражений являются ограниченными А-нормальными формами (Flanagan et al., 1993). 

\textbf{Индекс конструктора и арность.} Каждый конструктор $C$ типа данных с $m$ конструкторами связан с уникальным индексом в диапазоне $1 \ldots m$. Точнее, индекс конструктора является его позицией в отсортированном в алфавитном порядке списке всех конструкторов данного типа. Например, стандартный тип данных для списка имеет два конструктора: \textit{Cons} имеет индекс 1 и \textit{Nil} имеет индекс 2. Конструктор с индексом $i$ обозначается как $C_i$, и арность конструктора $C$ обозначается как $\#C$.

\subsection{Примитивные применения}
В ленивом языке применение примитивной функции, такой как (+), (-) или (<=) требует специальной обработки: целочисленные аргументы должны быть полностью вычислены перед тем как применение будет редуцировано. Одним из простых подходов является трансформация бинарного примитивного применения с помощью правила:
\begin{equation} \label{eq:rule_primitive_applications}
p \; e_0 \; e_1 \rightarrow e_1 \; (e_0 \; p)
\end{equation}

вместе с правилом редукции во время исполнения:
\begin{equation} \label{eq:reduce_primitive_applications}
n \; e \rightarrow e \; n
\end{equation}

для полностью вычисленного целочисленного литерала $n$. Для иллюстрации данного подхода, рассмотрим выражение \textit{(+) (tri 1) (tri 2)}. Благодаря применению правила (\ref{eq:rule_primitive_applications}) во время компиляции, выражение трансформируется в \textit{tri 2 ((tri 1) (+))}. Во время исполнения, редукция проводится следующим образом:

\begin{align*}
& tri \; 2 \; ((tri \; 1) \; (+)) & \{ tri \; 2 \; \text{вычисляется в} \; 3 \} & \\
& = 3 \; ((tri \; 1) \; (+)) & \{ \text{Правило (2)} \} & \\
& = (tri \; 1) \; (+) \; 3 &  \{ tri \; 1 \; \text{вычисляется в} \; 1 \} & \\
& = 1 \; (+) \; 3 & \{ \text{Правило (2)} \} & \\
& = (+) \; 1 \; 3
\end{align*}

После трансформации с помощью правила (\ref{eq:rule_primitive_applications}), \textit{tri} выглядит как:
\begin{verbatim}
tri n = case 1 (n (<=)) of
  { False -> n (tri (1 (n (-))) (+)) ; True -> 1 }
\end{verbatim}

В Главе 5 мы представляем более эффективные техники для работы с примитивными применениями.

\subsection{Частные применения (Case expressions)}
Эта глава описывает как компилируются частные выражения. Сперва расмотрим кодирование по Скотту (Scott, 1968) недавно переоткрытое Jansen et al (2007). После этого дадим несколько уточнений для данного кодирования.

\textbf{Кодирование по Скотту/Янсену.} Первый шаг кодирования - генерация для каждого конструктора $C_i$ типа данных с $m$ конструкторами определения функции:
\begin{equation} \label{eq:scott_encoding_1}
C_i \; x_i \ldots x_{\#C_i} \; k_1 \ldots k_m = k_i \; x_1 \ldots x_{\#C_i}
\end{equation}

Идея в том, что каждый конструктор данных $C_i$ закодирован как функция, которая берет $\#C_i$ аргументов конструктора и $m$ продолжений (continuations). Функция, кодирующая конструктор $C_i$, передает аргументы конструктора i-тому продолжению Для примера, конструкторы списка трансформируются в следующие функции:

\begin{verbatim}
Cons x xs c n = c x xs
Nil       c n = n
\end{verbatim}

Теперь частное выражение следующей формы:
\begin{equation} \label{eq:scott_encoding_2}
case \; e \; of \; \{ \; C_1 \; \vec{x}_1 \; \rightarrow e_i ; \ldots ; \; C_m \; \vec{x}_m \rightarrow e_m \; \}
\end{equation}

трансформируется в:
$$
e \; (alt_1 \;  \vec{v}_1 \; \vec{x}_1 ) \ldots (alt_m \;  \vec{v}_m \; \vec{x}_m )
$$
, где $\vec{v}_i$ - свободные переменные, появляющиеся в i-той частной альтернативе и каждый $alt_i$ для $i \in [1 \ldots m]$ имеет определение:

$$
	alt_i \; \vec{v}_i \; \vec{x}_i = e_i
$$

Для примера, функция \textit{append} трансформируется в:
\begin{verbatim}
append xs ys = xs (consCase ys) (nilCase ys)
consCase ys x xs = Cons x (append xs ys)
nilCase  ys      = ys
\end{verbatim}

Заметьте, что применение \textit{nilCase} можно редуцировать во время компиляции. Это следствии того, что конструктор \textit{Nil} имеет арность 0.

\textbf{Другой пример.} Теперь посмотрим на пример крупнее - вычисление базовых арифметических выражения.
\begin{verbatim}
eval x y e = case e of {
  Add n m -> (+) (eval x y n) (eval x y m);
  Neg n   -> (-) 0 (eval x y n);
  Sub n m -> (-) (eval x y n) (eval x y m);
  X       -> x;
  Y       -> Y;
}
\end{verbatim}

После преобразования и подстановки (in-lining) нулевых случаев, мы имеем:
\begin{verbatim}
eval x y e = e (add x y) (neg x y) (sub x y) x y
add  x y n m = (+) (eval x y n) (eval x y m)
neg  x y n   = (-) 0 (eval x y n)
sub  x y n m = (-) (eval x y n) (eval x y m)
\end{verbatim}

Посмотрите на объемное тело \textit{eval}: оно содержит три вложенных применений функций и несколько повторяющихся ссылок на $x$ и $y$. В типичной реализации функционального языка программирования большие тела функций более дороги для создания, чем маленькие.

\subsection*{Улучшение 1} 
Вместо того, чтобы частично применять каждую альтернативную функцию в частном выражении к свободным переменным, которые относятся к данной функции, мы можем определить каждую такую функцию так, чтобы она брала \textit{все} свободные переменные, появляющиеся в \textit{любой} альтернативе. Альтернатива в частном выражении может просто игнорировать переменные, которые ей не нужны. Так что вместо этого трансформируем частное выражение в:
$$
e \; alt_1 \ldots alt_m \; \vec{v}
$$ 
, где $\overrightarrow{v}$ - объединение свободных переменных в каждой альтернативы частного выражения, и каждая $alt_i$ для $i \in [1\ldots m]$ имеет определение:
$$
alt_i \; \vec{x}_i \; \vec{v} = e_i
$$
Каждая функция-альтернатива в частном выражении теперь сначала берет аргументы конструктора, потом свободные переменные, а не наоборот. Для иллюстрации, \textit{append} теперь выглядит как:
\begin{verbatim}
append xs ys = xs consCase nilCase ys
consCase x xs ys = Cons x (append xs ys)
nilCase       ys = ys
\end{verbatim}

И \textit{eval} преобразуется в:
\begin{verbatim}
eval x y e = e add neg sub xCase yCase x y
add   n m x y = (+) (eval x y n) (eval x y m)
neg   n   x y = (-) 0 (eval x y n)
sub   n m x y = (-) (eval x y n) (eval x y m)
xCase     x y = x
yCase     x y = y
\end{verbatim}

Новые тела \textit{append} и \textit{eval} \textit{не содержат} вложенных применений функций и повторяющихся ссылок. Очевидным недостатком является то, что мы должны предоставить функции для 0-арных альтернатив конструкторов \textit{nilCase}, \textit{xCase} и \textit{yCase}. Но наше следующее улучшение подготавливает способ для нивелирования цены такого применения этих функций.

\subsection*{Улучшение 2}
Теперь у нас есть длинный ряд прилегающих констант в теле \textit{eval}. Для того, чтобы представить эти коснтанты эффективным образом (смотри Главу 2.7), мы помещаем их в \textit{таблицу частных случаев} (case table). Частные выражения трансформируются в:
$$
e \; <alt_1, \ldots, alt_m> \; \vec{v}
$$
и каждый конструктор $C_i$ кодируется как:
$$
C_i \; x_1 \ldots x_{\#C_i} \; t = (t \; ! \; i) \; x_1 \ldots x_{\#C_i}
$$
, где $t \; ! \; i$ возвращает i-ый элемент таблицы частных случаев $t$.

\subsection*{Улучшение 3}
Вычислитель может обрабатывать конструкторы эффективнее, чем обобщенные определения функций. Мы можем предоставить следующее правило редукции для конструкторов:
$$
C_i \; e_1 \ldots e_{\#C_i} \; t \; \rightarrow \; (t \; ! \; i) \; e_1 \ldots e_{\#C_i}
$$
Данное правило заменяет конструктор функцией-альтернативой в частном выражении с помощью поиска в таблице частных случаев, используя индекс конструктора. Однако, это правило \textit{также} теряет аргумент t. В результате реализация будет вынуждена перемещать аргументы конструктора вниз по стеку. Правило редукции, которое не требует перемещения аргументов:
\begin{equation} \label{eq:reduce_rule_constructors}
C_i \; e_1 \ldots e_{\#C_i} \; t \; \rightarrow \; (t \; ! \; i) \; e_1 \ldots e_{\#C_i} \; t
\end{equation} 

Чтобы принять во внимание факт того, что t не было сброшено, определение функций-альтернатив принимает форму:
$$
alt_i \; \vec{x}_i \; t \; \vec{v} = e_i
$$

Финальная версия \textit{append}:
\begin{verbatim}
append xs ys = xs <consCase, nilCase> ys
consCase x xs t ys = Cons x (append xs ys)
nilCase       t ys = ys
\end{verbatim}

Аргумент t просто игнориуется функциями-альтернативами. Финальная версяи \textit{tri}:
\begin{verbatim}
tri n = 1 (n (<=)) <falseCase, trueCase> n
falseCase t n = n (tri (1 (n (-))) (+))
trueCase  t n = 1
\end{verbatim}

В главах 3.3 и 4.7 мы увидим как эти улучшения позволяют принимать эффективные решения на уровне реализации.

\subsection{Подстановка}
Определение \textit{append} больше не является явно рекурсивным. Это последствие разделения альтернатив частного выражения на определения новых функций. Однако, прямая рекусрия легко восстановима: просто подставить (in-line) определение \textit{append} в теле \textit{consCase}.
\begin{verbatim}
consCase x xs t ys =
  Cons x (xs <consCase, nilCase> ys)
\end{verbatim}

Эта трансформация демонстрирует следующее общее правило подстановки: \textit{подставлять насыщенные приложения функций с плоскими телами}. Подстановка плоского выражения \textit{e} часто является большим выигрышем, так как она устраняет редукцию, и \textit{e} часто не больше чем, применение, которое оно заменяет.

\subsection{Графы выражений}
В целях реализации обычно удобно делать структурный граф тел функций явным с помощью преобразования их к графам выражений (Глава 2.2). Это достигается с помощью трех правил преобразования.
\begin{enumerate}
\item Поднятие вложенных применений в привязки объявлений (let bindigns):
$$
e_1 \ldots (e_i) \ldots e_n \rightarrow let \; \{ \; x = e_i \; \} in e_1 \ldots x \ldots e_n
$$
, где $e_i$ является применением или выражением объявления, и $x$ - новая переменная.
\item Поднятие выражений объявлений из тел выражений объявления:
$$
let \; \{ \; \vec{b}_0 \; \} \; in \; (let \; \{ \vec{b}_1 \} \; in \; e) \rightarrow let \; \{ \; \vec{b}_0 ; \vec{b}_1 \; \} \; in \; e
$$
\item Поднятие выражений объявления из привязок объявлений:
$$
let \{ \ldots ; x = let \; \{ \vec{b} \} \; in \; e_0 ; \ldots \} \; in \; e_1 \rightarrow \\
	let \; \{ \ldots; \vec{b} ; x = e_0 ; \ldots \} \; in \; e_1
$$
\end{enumerate}

Данные правила принимают на себя переименование переменных, чтобы удостовериться в отсуствии затенения переменных (variable shadowing). Для иллюстрации последнего, определение \textit{falseCase} становится:
\begin{verbatim}
falseCase t n =
  let {x0 = tri x1 (+); x1 = 1 x2; x2 = n (-)} in n x0
\end{verbatim}

Легко увидеть число и длину применений в графе выражений. Например, \textit{falseCase} содержит четыре применения и ее самое длинное применение, \textit{tri x1 (+)}, имеет длину три.

\subsection{Шаблонный код}
Каждое определение функции теперь имеет форму:
$$
f \; x_0 \ldots x_n = let \; \{ \; v_0 = e_0; \ldots ; v_m = e_m \} \; in \; e
$$
, где каждое выражение плоское (и список привязок объявлений может быть пустым). Это представление очень близко к \textit{шаблонному коду}, который фактически может быть непосредственно выполнен на Редуцероне. Мы определим шаблонный код как тип данных Haskell, прокладывая путь к семантике исполнения, которая определена в Главе 3. Для того, чтобы выдвинуть это определение семантики на первый план и провести различия между ней и кодом F-lite, мы предваряем данные определения символом '>'.

В шаблонном коде программа определна как список шаблонов.
\begin{verbatim}
> type Prog = [Template]
\end{verbatim}

Шаблон представляет определение функции. Оно содержит \textit{арность}, \textit{хребтовое применение (spine application)} и список \textit{вложенных применений (nested applications)}.
\begin{verbatim}
> type Template = (Arity, App, [App])
> type Arity = Int
\end{verbatim}

Хребтовое определение содержит тело выражения объявления, относящиеся к определению графа выражения, и вложенные определения содержат привязки выражения объявления. Применения плоские и представлены как списки атомов. 
\begin{verbatim}
> type App = [Atom]
\end{verbatim}

Атом - это маленький помеченный кусок нерекурсивных данных.
\begin{verbatim}
> data Atom =
>    FUN Arity Int -- Функция с арностью и адресом
>  | ARG Int       -- Ссылка на аргумент функции
>  | PTR Int       -- Указатель на применение
>  | CON Arity Int -- Конструктор с арностью и индексом
>  | INT Int       -- Целочисленная константа
>  | PRI String    -- Имя примитивной функции
>  | TAB Int       -- Таблица частных случаев
\end{verbatim}

После применения преобразований, описанных в Главах от 2.3 до 2.6, F-lite программы могут быть компилированы в шаблонный код Редуцерона с помощью схемы компилирования, описанной на рисунке \ref{fig:compilation_sheme}. Следующие параграфы описывают, менее формально, как таки программы компилируются в шаблонный код.

\begin{figure}[t]
\begin{align*}
D \llbracket f_i \; x_0 \ldots x_n = let \left\lbrace v_0 = e_0; \ldots; v_m = e_m \right\rbrace in \; e \; \rrbracket &= \left( n+1, A_\sigma \llbracket e \rrbracket, \left[ A_\sigma \llbracket e_0 \rrbracket, \ldots, A_\sigma \llbracket e_m \rrbracket \right] \right) \\
\textbf{where} \; & & \\
\sigma &= [x_0 \mapsto \textit{ARG} \; 0, \ldots, x_n \mapsto \textit{ARG} \; n, \\
       &\;\;\;\;\;\;  v_0 \mapsto \textit{PTR} \; 0, \ldots, v_m \mapsto \textit{PTR} \; m] \\
\\
A_\sigma \llbracket e_0 \ldots e_n \rrbracket &= [E_\sigma \llbracket e_0 \rrbracket, \ldots, E_\sigma \llbracket e_n \rrbracket ] \\
\\
E_\sigma \llbracket n \rrbracket &= \textit{INT} \; n \\
E_\sigma \llbracket p \rrbracket &= \textit{PRI} \; p \\
E_\sigma \llbracket v \rrbracket &= \sigma \; v \\
E_\sigma \llbracket C_i \rrbracket &= \textit{CON} \; \#C_i \; i \\
E_\sigma \llbracket f_i \rrbracket &= \textit{FUN} \; \#f_i \; i \\
E_\sigma \llbracket \langle f_i, f_{i+1}, \ldots, f_j \rangle \rrbracket &= \textit{TAB} \; i
\end{align*} 
\label{fig:compilation_sheme}
\caption{Схема компиляции из трансформированных F-lite программ в шаблонный код Редуцерона. Схема D применяется к определениям функций; схема A применяется к применениям; схема E применяется к атомарным выражениям; и $\sigma$ определяет соответсвие из переменных в атомы.}
\end{figure}

\textbf{Функции.} Дан список определений функции:
$$
f_0 \; \vec{x}_0 = e_0, \ldots, f_n \; \vec{x}_n = e_n
$$
Каждый идентификатор фукнции $f_i$, появляющийся в $e_0 \ldots e_n$, транслируется в атом \textit{FUN \#f i}, где \textit{\#f} - арность функции $f$.

\textbf{Аргументы.} В каждом определении $f \; x_0 \ldots x_n = e$ каждая переменная $x_i$, появляющаяся в $e$, транслируется в атом \textit{ARG i}.

\textbf{Переменные в привязках выражения объявления.} В каждом графе выражений:
$$
let \; \{ \; x_0 = e_0 ; \ldots ; x_n = e_n \} \; in \; e
$$
Каждый $x_i$, появляющаяся в $e$, $e_0\ldots e_n$ транслируется в атом \textit{PTR i}.

\textbf{Целочисленные, примитивы и конструкторы.} Целочисленная константа $n$, примитив $p$ и конструктор $C_i$ транслируются в атомы \textit{INT n}, \textit{PRI p} и \textit{CON \#$C_i$ i} соответственно.

\textbf{Таблицы частных случаев.} Дан лист определений функции:
$$
f_0 \; \vec{x}_0 = e_0, \ldots, f_n \; \vec{x}_n = e_n
$$

Каждая таблица частных случаев $\langle f_i, \ldots, f_j \rangle$, появляющаяся в $e_0 \ldots e_n$, транслируется в атом \textit{TAB i}. Договоримся, что функции в каждой таблице частных случаев определены по соседству в шаблонном коде.

\textbf{Пример.} Рассмотрим следующую программу, включающую функцию \textit{tri}:
\begin{verbatim}
main          = let { } in tri 5
tri       n   = let { x = n (<=) } in 1 x <falseCase, trueCase> n
falseCase t n = let { x0 = tri x1 (+); x1 = 1 x2; x2 = n (-) } in n x0
trueCase  t n = let { } in 1
\end{verbatim}

Шаблонный код для данной программы представлен ниже:
\begin{verbatim}
> tri5 :: Prog
> tri5 = [ (0, [FUN 1 1, INT 5], [])
>        , (1, [INT 1, PTR 0, TAB 2, ARG 0],
>              [[ARG 0, PRI "(<=)"]])
>        , (2, [ARG 1, PTR 0],
>              [[FUN 1 1, PTR 1, PRI "(+)"],
>               [INT 1, PTR 2],
>               [ARG 1, PRI "(-)"]])
>        , (2, [INT 1], []) ]
\end{verbatim}

Заметим, что каждое определение функции соответствует шаблонну, представленный как кортеж длины три. Первая компонента каждого шаблона - арность функции. Вторая и третья компоненты представляют тело выражения объявления у функции и привязки выражения объявления соответственно. Функции без привязок отображаются в шаблоны с пустой третьей компонентой. Функции, применения и аргументы обознаются по позиции. Например, атом \textit{FUN 1 1} в первом шаблоне представляет вызов функции арности 1, которая находится по индексу 1 в списке шаблонов (в данном случае, вызов функции \textit{tri}). И атом \textit{PTR 2} в третьем шаблоне является указателем на применение по индексу 2 в списке применений, соответствующему привязкам выражения объявления (в данном случае, применение называется \textit{x2}).

\section{Рабочая семантика}
Данная глава определяет \textit{рабочую семантику малых шагов (small-step operational semantics} для Редуцерона. Существует две главных причины привести семантику:
\begin{itemize}
\item Точно определить как работает Редуцерон;
\item Подчеркнуть низкоуровневый параллелизм, присуствующий в редукции графа, испольуземой в Редуцероне.
\end{itemize}
Мы нашли очень удобной прямую запись в Haskell данной семантики: перед тем, как приступать к низкоуровневой реализации, можно проанализировать сложность и производительность различных дизайнерских решений и оптимизаций.

Сердцем определения семантики является функция перехода состояния:
\begin{verbatim}
> step :: State -> State
\end{verbatim}

, где состоянием является четверка, содержащая программу, кучу, редукционный стек и стек обновлений.
\begin{verbatim}
> type State = (Prog, Heap, Stack, UStack)
\end{verbatim}

Куча моделируется как список приложений и может быть проиндексирована с помощью адреса кучи:
\begin{verbatim}
> type Heap = [App]
> type HeapAddr = Int
\end{verbatim}

Элемент в куче может быть изменен с помощью функции обновления:
\begin{verbatim}
> update :: HeapAddr -> App -> Heap -> Heap
> update i a as = take i as ++ [a] ++ drop (i+1) as
\end{verbatim}

Реудкционный стек также моделирвется как список узлов, для которого верхний элемент стека является первым и нижный элемент является последним.
\begin{verbatim}
> type Stack = [Atom]
> type StackAddr = Int
\end{verbatim}

Также присуствует стек обновлений:
\begin{verbatim}
> type UStack = [Update]
> type Update = (StackAddr, HeapAddr)
\end{verbatim}

Значение программы $p$ определено с помощью \textit{run p}, где:
\begin{verbatim}
> run :: Prog -> Int
> run p = eval initialState
>   where initialState = (p, [], [FUN 0 0], [])

> eval (p, h, [INT i], u) = i
> eval s = eval (step  s)
\end{verbatim}

Начальное состояние вычислителя содержит программу, пустую кучу, стек с одним элементом - вызовом \textit{main} и пустой стек обновлений. Главный шаблон имеет арность 0 и мы считаем, что этот шаблон находится по адресу 0. Для демонстрации этого, \textit{run tri5} выводит 15. В следующих подглавах определена центральная функция \textit{step}.

\subsection{Редукция примитивов}
Функция \textit{prim} применяет примитивную функцию к двум аргументам, подданых как полностью вычисленные целочисленные значения.
\begin{verbatim}
> prim :: String -> Atom -> Atom -> Atom
> prim "(+)" (INT n) (INT m) = INT (n+m)
> prim "(-)" (INT n) (INT m) = INT (n-m)
> prim "(<=)" (INT n) (INT m) = bool (n<=m)
\end{verbatim}

Примитив сранвения возвращает логическое значение. Оба конструктора \textit{boolean} имеют арность 0; \textit{False} имеет индекс 0 и \textit{True} имеет индекс 1.

\begin{verbatim}
> bool :: Bool -> Atom
> bool False = CON 0 0
> bool True  = CON 0 1
\end{verbatim}

\subsection{Нормальные формы}
Чиcло аргументов, требуемое атому, на вершине редукционного стека определено функцией \textit{arity}.
\begin{verbatim}
> arity :: Atom -> Arity
> arity (FUN n i) = n
> arity (INT i) = 1
> arity (CON n i) = n+1
> arity (PRI p) = 2
\end{verbatim}

Для редукции целочисленного значения вычислителю требуется один аргумент, как показано в правиле преобразования (2). И чтобы редуцировать конструктор арности \textit{n}, вычислителю необходимо \textit{n+1} аргументов (аргумента конструктора \textit{и} таблица частных случаев) как показано в правиле преобразования (5).

Арность атома используется только для определения достижения \textit{нормальной формы}. Нормальная форма - это применение длины \textit{n}, чей первый атом имеет арность $\geq n$.

О некоторых функциях, такие как альтернативы в частных выражениях, \textit{статически} известно, что они \textit{никогда} не будут применяться частично, так что они не могут быть первыми атомами нормальной формы. Такая функция, пусть с адресом \textit{n}, может быть представлена с помощью атома \textit{FUN 0 n}.

\subsection{Пошаговая редукция}
Определены по одному правилу редукции для каждого возможного типа атома, которые могут появиться на вершине редукционного стека.

\textbf{Размотка.} Если вершиной редукционного стека является указатель \textit{x} на применение на куче, вычисление продолжается с помощью \textit{размотки (unwinding)}: копирования формы применения с кучи в редукционны стек, где она может быть редуцирована. Мы также должны убедиться, что когда вычисление применения завершено, положения \textit{x} на куче может быть обновлено результатом вычисления. Так что адрес в куче \textit{x} и текущий размер редукционного стека кладутся на вершину стека обновления.

\begin{verbatim}
> step (p, h, PTR x:s, u) = (p, h, h!!x ++ s, upd:u)
>   where upd = (1+length s, x)
\end{verbatim}  

\textbf{Обновление.} Вычисление применения считается завершенным, когда аргументу, индекс которого больше чем \textit{n}, необходима разница между текущим размером редукционного стека и адресом стека на вершине стека обновления. Если это условие выполняется, тогда на вершине редукционного стека находится нормальная форма арности \textit{n}, которая должна быть записана в кучу.
\begin{verbatim}
> step (p, h, top:s, (sa,ha):u)
>    | arity top > n = (p, h', top:s, u)
>    where
>      n  = 1+length s - sa
>      h' = update ha (top:take n s) h
\end{verbatim}

\textbf{Целочисленные значения и примитивы.} Целочисленные константы и примитивные функции могут быть редуцированы, как показано в главе 2.3, но главы 5.2 и 5.3 представляют улучшения данного подхода.
\begin{verbatim}
> step (p, h, INT n:x:s, u) = (p, h, x:INT n:s, u)
> step (p, h, PRI f:x:y:s, u)
\end{verbatim}

\textbf{Конструкторы.} Применения конструкторов, закодированных по Скотту, редуцируются индексацией таблицы частных случаев, как описано в главе 2.4.
\begin{verbatim}
> step (p, h, CON n j:s, u) = (p, h, FUN 0 (i+j):s, u)
>   where TAB i = s !! n
\end{verbatim}

Присутствует недостаток информации для вычисления арности функции-альтернативы по адресу \textit{i+j}. Однако, арность нуль может быть использовано, так как статически известно, что функция-альтернатива не может быть частично применена (глава 3.2).

\textbf{Применения функций.} Чтобы применить функцию \textit{f} арности \textit{n}, \textit{n+1} элементов должны быть извлечены из редукционного стека, создается хребтовое применение тела \textit{f} и кладется на вершину редукционного стека, и оставшиеся применения создаются и добавляются в кучу.

\begin{verbatim}
> step (p, h, FUN n f:s, u) = (p, h', s', u)
>   where
>     (arity, spine, apps) = p !! f
>     h' = h ++ map (instApp s h) apps
>     s' = instApp s h spine ++ drop arity s
\end{verbatim}

Создание тела функции включает замещение формальных параметров аргументами из редукционного стека и превращения относительных указателей в абсолютные.
\begin{verbatim}
> instApp :: Stack -> Heap -> App -> App
> instApp s h = map (inst s (length h))
>
> inst :: Stack -> HeapAddr -> Atom -> Atom
> inst s base (PTR p) = PTR (base + p)
> inst s base (ARG i) = s !! i
> inst s base a = a
\end{verbatim}

\section{Реализация}
Теперь мы уточним семантическое определение на непосредственную реализацию, которая выполняется на FPGA. Конкретно, целевым устройством является Xilinx Virtex-5 среднего класса, выпущенное в 2008. Наш главный принцип проектирования - производить столько редукций, сколько возможно за каждый такт. Наша реализация производит каждое семантическое правило редукции в \textit{один такт}, и частота примерно равна 100 MHz, скромная, но приличная частота для процессороподобных разработок на FPGA.

\subsection{Низкоуровневый параллелизм}
Ниже описаны три главных возможностей для параллелизма, которые были использованы в данной реализации.

\textbf{Параллельная память.} Состояние редукционной машины включает четыре независимых области памяти: программа, куча, редукционный стек и стек обновлений. Большинство правил редукции относятся к и модифицируют более чем одной области памяти. Например, правило редукции для развинчивания пишет и в редукционный стек, и в стек обновлений. Если эти четыре области памяти реализованы как четыре раздельных модуля, тогда они могут быть адресованы \textit{параллельно}, избегая конкуренции, которая бы появлиась, если бы они были все в одном модуле памяти.

\textbf{Широкая шина памяти.} Многие правила редукции включают передачу применений из/в память. Если память допускает одновременный доступ только к одному атому, то передача одного применения выливается в \textit{несколько} доступов к памяти. Если шина памяти достаточно широка для доступа к целому применению одновременно, передача применения происходит за одно обращения к памяти.

\textbf{Параллельное создание.} Редукционное правила применения функции включает создание каждого применения в теле функции и добавления его в кучу. Каждый атом в приложении может быть создан параллельно, что показано использование \textit{map} в определении \textit{instApp}. Тогда широкая шина кучи позволяет записывать созданное применение в кучу за одно обращение. Более того, каждое применение в теле функции также может быть создано параллельно, что показано использование \textit{map} в семантическом правиле применения функции. Если более чем одно применение может быть добавлено в кучу, эти применения создаются параллельно. Все это возможно с помощью наложения значительных ограничений на структуру шаблонов, как показано в главе 4.2.

\subsection{Ограниченное создание шаблонов}
\textbf{Максимальная длина применения.} Идеально, мы должны иметь достаточно широкую шину данных для передачи любого применения целиком в один момент. Однако, это невозможно без некоторой верхней границы длины применения. Поэтому вводится граница \textit{MaxAppLen} на количество атомов, которые могут находится в применении.

Для обработки применений, чья длина больше чем \textit{MaxAppLen}, они разделяются на два или более мелких. Например, если \textit{MaxAppLen} равен 3, то применение \textit{f a b c d e} может быть разбито на \textit{((f a b) c d) e}, давая три применения вместо одного. 

Альтернативный способ ограничить длину применения - разбить применения на куски, которые расположены последовательно в памяти, с конечным куском, специально помеченный маркером останова. Данный подход (Naylor \& Runciman, 2008) эффективнее в некоторых случаях, но не может быть представлен как преобразование в ядровом языке.

\textbf{Максимальная длина хребтового применения.} Хребтовые применения особенны, так как во время применения функции, они записываются в стек, не в кучу. Так что лучше ввести отдельную максимальную длилун для хребтовых применений: \textit{MaxSpineLen}.

\textbf{Максимальное число применений на шаблон.} Идеально, все применения в шаблоне должны создаваться одновременно. Чтобы позволить это в реализации, вводится граница, названная \textit{MaxAppsPerBody}, на максимальное число применений, которые могут быть в теле шаблона. Чтобы обрабатывать шаблоны, содержащие больше применений, чем \textit{MaxAppsPerBody}, выполняется техника, названная \textit{разбиение шаблона (template splitting)}.

\subsection{Разбиение шаблона}
\textbf{Пример.} Покажем разбиение шаблона на примере. Рассмотрим следующий шаблон, представляющий функцию \textit{falseCase} из программы \textit{tri5}, определенной в главе 2.7.
\begin{verbatim}
(2, [ARG 1, PTR 0]                  -- Хребет
  , [ [FUN 1 1, PTR 1, PRI "(+)"]   -- Применение 1
    , [INT 1, PTR 2]                -- Применение 2
    , [ARG 1, PRI "(-)"] ] )        -- Применение 3
\end{verbatim}

Он содержит одно хребтовое применение и три вложенных. Если \textit{MaxAppsPerBody} равен двум, тогда этот шаблон разделяется на два подшаблона. Первый подшаблон заменяет исходный шаблон в программе \textit{tri5}:
\begin{verbatim}
(0, [FUN 0 4]                       -- Промежуточный хребет
  , [ [FUN 1 1, PTR 1, PRI "(+)"]   -- Применение 1
    , [INT 1, PTR 2] ] )            -- Применение 2
\end{verbatim}

Второй подшаблон добавляется к программе в следующих свободных адресах: адрес 4 в терминах программы \textit{tri5}.
\begin{verbatim}
(2, [ARG 1, PTR (-2)]               -- Хребет
  , [ [ARG 1, PRI "(-)"] ])         -- Применение 3вызывает
\end{verbatim}

Хребет первого подшаблона просто вызывает второй подшаблон. Здесь есть три важных пункта:
\begin{itemize}
\item Первый подшаблон содержит три применения, которые все еще больше чем ограничение \textit{MaxAppsPerBody}. Однако, на уровне реализации, мы не считаем хребтовое применение формы \textit{[FUN 0 f]} как применение: Оно может быть интерпретировано как "переход к шаблону \textit{f}" и не обращается к никаким адресам в куче или стеке.
\item Во втором подшаблоне каждый атом формы \textit{PTR n} заменяется на \textit{PTR (n-2)}, чтобы принять во внимание факт того, что создание первого подшаблона увеличит размер кучи на два.
\item Арность первого подшаблона установлена в нуль: элементы не извлекаются со стека, так как они могут быть необходимы второму подшаблону.
\end{itemize}

\begin{figure}[t]
\centering
\begin{verbatim}
split :: Int -> Template -> [Template]
split f t@(arity, spine, apps)
  | length apps < maxAppsPerBody = [t]
  | otherwise =
      (0, [FUN 0 f], take maxAppsPerBody apps)
    : split (f+1) (arity, spine, drop maxAppsPerBody apps')
  where
    apps' = map (map decPTR) apps

decPTR :: Atom -> Atom
decPTR (PTR n) = PTR (n - maxAppsPerBody)
decPTR a = a
\end{verbatim}
\caption{Применение \textit{split f t} разделяет шаблон на список подшаблонов, где \textit{f} - следующий незанятый адрес шаблона. Последний возвращаемый подшаблон заменяет оригинальный неразделенный шаблон, и другие подшаблоны присоединяются к программе начиная с адреса \textit{f}.}
\label{fig:tempale_split_func}
\end{figure}

\textbf{Алгоритм разделения шаблонов.} В общем случае, разделение шаблонов выполняется с помощью функции \textit{split}, определенной на рис.~\ref{fig:tempale_split_func}. Чтобы проиллюстрировать это, рассмотрим следующее тело функции, где \textit{f}, \textit{g} и \textit{h} идентификаторы функций, и \textit{x} и \textit{y} аргументы:
\begin{verbatim}
f x (g (h y) x)
\end{verbatim}

Предпологая, что \textit{MaxAppsPerBody} равно 2, данное тело будет реализовано как два шаблона: один, содержащий применения \textit{h} и \textit{g}, и другой, содержащий применение \textit{f}. Два шаблона озанчают, что будут необходимы два шака редукции для создания данного тела.

Данный метод разделения довольно упрощенный, и здесь может быть множество улучшений. Одна из альтернатив может абстрагировать второй аргумент \textit{f} с помощью ввода:
\begin{verbatim}
i x y = g (h y) x
\end{verbatim}

Что позволяет записать меньший эквивалент тела:
\begin{verbatim}
f x (i x y)
\end{verbatim}

\begin{table}
\centering
\caption{Влияние длины применения, хребтового применения и количества применений в теле шаблона на число редукций и использования кучи.}
\label{tab:bounds_effect}
\begin{tabularx}{\textwidth}{XXXX}
\hline\hline
Параметр & Ограничение & Редукции & Куча \\
\hline
\textit{MaxAppLen} & 2 & 1.00 & 1.00 \\
& 3 & 0.84 & 1.00 \\
& 4 & 0.83 & 1.30 \\
& 5 & 0.82 & 1.57 \\
& 6 & 0.82 & 1.89 \\
\hline
\textit{MaxSpineLen} & 2 & 1.00 & 1.00 \\
& 3 & 0.82 & 0.76 \\
& 4 & 0.76 & 0.67 \\
& 5 & 0.71 & 0.60 \\
& 6 & 0.70 & 0.57 \\
\hline
\textit{MaxAppsPerBody} & 1 & 1.00 & 1.00 \\
& 2 & 0.89 & 1.00 \\
& 3 & 0.85 & 1.00 \\
& 4 & 0.85 & 1.00 \\
\hline\hline
\end{tabularx}
\end{table} 

Такое малое тело может быть реализовано как один шаблон и создано за один шаг редукции. В случае, когда второй аргумент \textit{f} никогда не потребуется, сохраняется один шаг редукции. В случае, когда требуется второй аргумент \textit{f}, необходима редукция \textit{i}, и не экономится шаг и не требуются лишние.

Так что разделение тел функций на уровне шаблонов не является единственным вариантом. Мы можем разделять тела функций на уровне комбинаторов F-lite; как показано выше, это может приводить к улучшению производительности.

\subsection{Выбор ограничений}
Мы должны выбирать значения ограничений \textit{MaxAppLen}, \textit{MaxSpineLen} и \textit{Max AppsPerBody} очень аккуратно: выбор слишком строгих устраняет полезный параллелизм; выбор слишком слабых тратит ресурсы. Наш выбор сделан исходя из эксперимента. Таблица~\ref{tab:bounds_effect} показывает влияние на производительность при изменения каждого параметра по очереди - не меняющиеся параметры фактически равны бесконечности. Количество редукций и использование кучи нормализованы для изменяющихся параметров и усреднены по ряду тестовых программ (смотри главу 6.1). Измерения получены с помощью PC релаизации рабочей семантики. Количество редукций представлено количеством вызывов функции \textit{step} в определении \textit{eval}. \footnote{Редукции конструкторов не принимаются во внимание, предупреждая оптимизацию, представленную в главе 4.7.} 

Выбранные ограничения: \textit{MaxAppLen = 4}, \textit{MaxSpineLen = 6} и \textit{MaxAppsPerBody = 2}. Измерения говорят о том, что \textit{MaxAppLen} равное трем предпочтительнее четырем из-за лучшего использования кучи; выбор четырех мотивирован другим параметром реализации - пределом арности - введенным в главе 4.5. \textit{MaxSpineLen} равное пяти не будет хуже шести, но выбор шести не стоит намного дороже на уровне реализации. \textit{MaxAppsPerBody} равное двум мотивировано тем, что три будет не намного лучше и два хорошо подходит под двупортовую память, доступную на FPGA.

\subsection{Разметка памяти}

\begin{table}
\caption{Размер и тип каждого модуля памяти.}
\label{tab:memory_units}
\begin{tabularx}{\textwidth}{Xlcc}
\hline\hline
Модуль памяти & Элемент & Биты на элемент & Кол-во элементов \\
\hline
Программа                   & \emph{Template} & 234 & \hspace{7pt}1 k \\
Куча                        & \emph{App}      & 77  & 32 k \\
Редукционный стек           & \emph{Atom}     & 18  & \hspace{7pt}8 k \\
Стек обновлений             & \emph{Update}   & 28  & \hspace{7pt}4 k \\
Стек таблиц частных случаев & \emph{Atom}     & 18  & \hspace{7pt}4 k \\
Пространство копирования    & \emph{App}      & 77  & 16 k \\
\hline\hline
\end{tabularx}
\end{table}
Xilinx Virtex-5 FPGA содержит 296 двупортовых блоков RAM, какждый из которых держит 18 килобит, давая в целом емкость RAM на чипе в 5,328 килобит. Каждый блок RAM является двупортовым, позволяя производить два независимых обращения за такт. Ширина шины данных и адреса каждого блока RAM настраиваема. Возможные кофигурации включают 1 килобит на 18 битов и 16 килобита на один бит, и множество возможностей между ними. Два 18 килобитных блока RAM могут быть склеены, давая дальнейшие возможные конфигурации от 1 килобита на 36 бита до 32 килобита на 1 бит.

Для простоты наша реализация использует только блоки RAM на FPGA, не используя RAM вне чипа. Это приводит к жесткому ограничению на количестов памяти, доступной реализации. (Возможность ввода внешенй памяти рассмотрена в главе 7.)

\textbf{Структура памяти.} Параллельные модули памяти, каждый из которых построенный из блоков RAM, перечислены в таблице~\ref{tab:memory_units} вместе с их вместимостью и типом элементов, хранимых в каждой адресуемой ячейке. Заметим, что каждый шаблон программы и применение в куче имеют одинаковые размеры. Два модуля памяти в конце таблицы описаны в главе 4.7 и 4.8 соответственно.

\textbf{Широкая память.} Широкая память кучи реализована с помощью соединения шин данных 77-ми 32 килобита на 1 бит блоков RAM и их склеенными шинами адреса. Это сделано на обоих портах каждого блока RAM, реализуя \textit{двупортную кучу (dual-port heap)}. Аналогично, широкая память программ реализована, используя 13 1 килобит на 18 бит блоков RAM, но в этом случае двупортность не требуется.

\textbf{Память стеков.} Верхние N элементов стека хранятся в специализированных стековых регистрах. В любой такт реализация стека позволяет: считывать верхние N элементов; снимать \textit{до} N элементов с вершины; и класть до N элементов на вершину. Если снятие и добавление происходят в одном такте, снятие производится до добавления. Одновременный доступ к верхним N элемента стека достигается с помощью координатного коммутатора (crossbar switch): ему требуется более чем 2,000 логических элементов, но меньше чем 1\% от вместимости FPGA. С его помощью достигается значительный уровень параллелизма, так что затраты окупают цели. Более детальное описание реализации стека на аппаратном уровне доступны в Naylor (2009b). 

\textbf{Ограничение арности.} Реализация стека параметризирована значением N, но требует, чтобы N было степенью двойки. Для стека обновления N устанавливается в 1, так как чтение и запись множества значений не приносит никакой пользы. Для редукционного стека,  нужно принять во внимание три соображения, имя в виду цель однотактовой редукции:
\begin{itemize}
\item только верхние N элементов стека доступны в любой такт, следовательно максимальное количество аргументов, которое может быть у функции - $N-1$; 
\item максимальная длина частично примененной функции или нормальной формы также $N-$;
\item выбор $N$ должно ползволять записть нормальной формы длины $N-1$ в кучу за один такт.
Так как два применения длины \textit{MaxAppLen} могут быть записаны в двупортовую кучу за один такт, и \textit{MaxAppLen} равно четырем, разумный выбор для $N$ равен восьми, так как нормальная форма длины семь может быть великолепно разбита на два применения длины четыре.
\end{itemize}

Для обработки функций, берущих более чем $N-1$ аргументов, может быть использован алгоритм абстрагирования (Turner, 1979). Нами был разработан незначительно измененный вариант (Naylor, 2009a) алгоритма абстрагирования, основанный на director strings (Dijkstra, 1980; Kennaway \& Sleep, 1988), который использует более крупнозернистый набор комбинаторов, чем алгоритм Turner'а. Однако мы заметили, что ни одна из тестовых програм, используемых в данной работе, не превышает предел арности равный 8.

\subsection{Одна редукция на машинный такт}
Память кучи и программ разработана так, чтобы удовлетворять следующим двум свойствам:
\begin{itemize}
\item \textbf{Свойство 1.} Если положение в памяти $x$ читается в такт $n$, то значение по адрессу $x$ становится доступным на шине данных памяти в такт $n+1$.
\item \textbf{Свойство 2.} Если значение пишется в память по адрессу $x$ в такт $n$, то новое значение по адресу $x$ не видно до такта $n+1$. 
\end{itemize}

Вехние элементы стека всегда доступны без задержки в тактах. Теперь покажем как каждое правило редукции в семантике может быть выполнено за один такт с учетом следующих двух инвариантов:
\begin{itemize}
\item \textbf{Инвариант 1.} Если вершина редукционного стека имеет форму \textit{PTR x}, тогда применение по адресу кучи $x$ доступно в этот момент времени на шине данных памяти кучи.
\item \textbf{Инвариант 2.} Если вершниа редукционного стека имеет форму \textit{FUN n f}, тогда шаблон по адресу программы $f$ доступен в этот момент времени на шине данных программной памяти.
\end{itemize}

\textbf{Размотка.} Вершина редукционного стека имеет форму \textit{PTR x}. Тогда применение, находящееся в этот момент времени на шине данных памяти кучи, допустим \textit{app}, является применением по адресу кучи $x$ (Инвариант 1). Производятся следующие параллельные транзакции в памяти за один такт:
\begin{itemize}
\item Применение \textit{app} переносится на вершину редукционного стека.
\item Обновление $(n,x)$ кладется на вершину стека обновления, где $n$ - размер редукционного стека перед изменением.
\item Первый атом \textit{app} является новой вершиной редукционного стека и используется для поиска в памяти кучи и программы для удовлетворения Инвариантов 1 и 2.
\end{itemize}

\textbf{Обновление.} Шина данных стека обновления используется для определения момента, когда необходимо обновление, и если необходимо, то по какому адресу кучи $x$. Если необходимо обновление, тогда нормальная форма доступна на шине данных редукционного стека. Производятся следующие параллельные транзации памяти за один такт:
\begin{itemize}
\item Если нормальная форма имеет длину мешьшую или равную четырем, то она записывается в кучу по адресу $x$.
\item Если нормальная форма имеет длину большую чем четыре, она разбивается на два применения максимальной длины четыре, одно из которых записывается в кучу по адресу $x$, и другое добавляется в кучу.
\item Верхний элемент стека обновления сбрасывается.
\item Производится поиск в памяти программы для выполнения Инварианта 2.
\end{itemize}

Поиск в кучу для удовлетворения Инварианта 1 не требуется, так как вершина редукционного стека не может быть формы \textit{PTR x} при выполнении операции обновления. Так что обновление требует два доступа к куче в худшем случае, которые могут быть произведены параллельно, благодаря двупортной памяти.

\textbf{Целочисленные константы, примитивы и конструторы.} Каждое из этих правил редукции включает только оперирование со стеком, и каждое из них непосредственно требует один такт.

\textbf{Применение функции.} Вершина редукционного стека имеет форму \textit{FUN n f}. Поэтому шаблон по адресу $f$, допустим $t$, доступен на шине данных (Инвариант 2). Здесь надо рассмотреть два случая:

\textit{Случай 1.} Если $t$ содержит хребтовое применение формы \textit{[FUN 0 f]}, тогда:
\begin{itemize}
\item создается до двух вложенных применений в $t$ и добавляются в кучу;
\item атом \textit{FUN 0 f} записывается на вершину редукционного стека;
\item функция $f$ ищется в памяти программы для удовлетворения Инварианта~2.
\end{itemize}

\textit{Случай 2.} Если $t$ имеет другю форму, тогда:
\begin{itemize}
\item создается нуль или одно вложенное применение в $t$ и добавляются в кучу;
\item создается хребтовое применение в $t$ и записывается в редукционный стек;
\item первый элемент созданного хребтового применения используется для поиска в памяти кучи и программы для удовлетворения Инвариантов~1~и~2.
\end{itemize}

В Случае 1, поиск в куче для удовлетворения Инварианта 1 не требутеся: известно, что вершина стека имеет форму \textit{FUN}, а не \textit{PTR}. Таким образом в каждом случае требуется не более двух доступов к куче.

\subsection{Стек таблиц частных случаев}
\begin{table}[t]
\caption{Влияние оптимизаций на число тактов в ряде программ}
\label{tab:clock-cycle_optimisations}
\begin{tabularx}{\textwidth}{L{1.3}C{0.7}C{1}C{1}C{1}C{1}C{1}}
\hline\hline
Программа & Основа & + Встраивание & + Стек частных случаев & + Избегание обновлений & + Инфиксные примитивы & + PRS \\
\hline
Adjoxo      & 1.00 & 0.85 & 0.71 & 0.54 & 0.43 & 0.36 \\
Braun       & 1.00 & 0.84 & 0.63 & 0.46 & 0.43 & 0.42 \\
Cichelli    & 1.00 & 0.93 & 0.77 & 0.56 & 0.42 & 0.41 \\
Clausify    & 1.00 & 0.79 & 0.59 & 0.48 & 0.41 & 0.41 \\
CountDown   & 1.00 & 0.95 & 0.86 & 0.70 & 0.49 & 0.31 \\
Fib         & 1.00 & 1.28 & 1.21 & 0.96 & 0.75 & 0.35 \\
KnuthBendix & 1.00 & 0.81 & 0.63 & 0.48 & 0.43 & 0.40 \\
Mate        & 1.00 & 0.83 & 0.67 & 0.50 & 0.43 & 0.40 \\
MSS         & 1.00 & 0.92 & 0.84 & 0.61 & 0.38 & 0.24 \\
OrdList     & 1.00 & 0.73 & 0.55 & 0.42 & 0.42 & 0.42 \\
PermSort    & 1.00 & 0.77 & 0.62 & 0.48 & 0.42 & 0.42 \\
Queens      & 1.00 & 0.75 & 0.68 & 0.51 & 0.40 & 0.21 \\
Queens$_2$  & 1.00 & 0.82 & 0.67 & 0.55 & 0.50 & 0.50 \\
SumPuz      & 1.00 & 0.95 & 0.80 & 0.60 & 0.50 & 0.48 \\
Taut        & 1.00 & 0.90 & 0.70 & 0.56 & 0.51 & 0.50 \\
While       & 1.00 & 0.93 & 0.77 & 0.58 & 0.50 & 0.49 \\
            &      &      &      &      &      &      \\
\textbf{Среднее} & 1.00 & 0.88 & 0.74 & 0.57 & 0.47 & 0.40 \\       
\hline\hline
\end{tabularx}
\end{table}

\begin{table}[t]
\caption{Влияние оптимизаций на использовании кучи в ряде программ}
\label{tab:heap_optimisations}
\begin{tabularx}{\textwidth}{L{1.3}C{0.7}C{1}C{1}C{1}C{1}C{1}}
\hline\hline
Программа & Основа & + Встраивание & + Стек частных случаев & + Избегание обновлений & + Инфиксные примитивы & + PRS \\
\hline
Adjoxo      & 1.00 & 0.80 & 0.80 & 0.80 & 0.49 & 0.41 \\
Braun       & 1.00 & 0.93 & 0.93 & 0.93 & 0.88 & 0.88 \\
Cichelli    & 1.00 & 0.97 & 0.97 & 0.97 & 0.36 & 0.33 \\
Clausify    & 1.00 & 0.59 & 0.59 & 0.59 & 0.42 & 0.42 \\
CountDown   & 1.00 & 0.97 & 0.97 & 0.97 & 0.53 & 0.33 \\
Fib         & 1.00 & 2.33 & 2.33 & 2.33 & 2.00 & 0.33 \\
KnuthBendix & 1.00 & 0.66 & 0.66 & 0.66 & 0.58 & 0.49 \\
Mate        & 1.00 & 0.45 & 0.45 & 0.45 & 0.29 & 0.25 \\
MSS         & 1.00 & 1.00 & 1.00 & 1.00 & 0.51 & 0.03 \\
OrdList     & 1.00 & 0.67 & 0.67 & 0.67 & 0.67 & 0.67 \\
PermSort    & 1.00 & 0.77 & 0.77 & 0.77 & 0.69 & 0.69 \\
Queens      & 1.00 & 0.54 & 0.54 & 0.54 & 0.39 & 0.11 \\
Queens$_2$  & 1.00 & 0.92 & 0.92 & 0.92 & 0.77 & 0.73 \\
SumPuz      & 1.00 & 1.06 & 1.06 & 1.05 & 0.74 & 0.63 \\
Taut        & 1.00 & 0.99 & 0.99 & 0.99 & 0.90 & 0.87 \\
While       & 1.00 & 0.95 & 0.95 & 0.95 & 0.81 & 0.80 \\
            &      &      &      &      &      &      \\
\textbf{Среднее} & 1.00 & 0.92 & 0.92 & 0.92 & 0.69 & 0.50 \\       
\hline\hline
\end{tabularx}
\end{table}

Редукция конструкторов изменяет только верхний элемент редукционного стека добавлением индеска конструктора к адресу таблицы частных случаев. Такое добавление \textit{в большинстве случаев} достаточно дешево, чтобы быть реализовано в комбинаторной логике (т.е. в нуль тактов) без удлинения критической части схемы. Проблема заключается в том, что таблица частных случаев должна быть извлечена из \textit{положения переменной} на стеке. Это требует наличия мультиплексора, делая комбинаторную логику более дорогой.

Для решения это проблемы мы вводим новую стековую память для хранения таблиц частных случаев. Во время размотки применения, содержащего таблицу частных случаев, таблица помещается на вершину \textit{стека таблиц частных случаев (case-table stack)}. Во время выполнения редукции конструктора необходимая таблица всегда находится на одной и той же позиции: на вершине стека таблиц частных случаев.

Таблицы~\ref{tab:clock-cycle_optimisations} и~\ref{tab:heap_optimisations} показывают влияние различных оптимизаций на число тактов и использования кучи в ряде тестовых программ. Вместе со стратегией встраивания, определенной в главе 2.5, оптимизация таблиц частных случаев приводит к значительному улучшению производительности в среднем. Другие оптимизации в таблицах~\ref{tab:clock-cycle_optimisations} и~\ref{tab:heap_optimisations} предоставлены в главе 5. Заметим, что в программе \textit{Fib}, встраивание имеет немного негативный характер: тело рекурсивного частного выражения вырастает до двух применений, каждое из которых необходимо разделить, что увеличивает время создания и размотки. Без встраивания разбиение применений не требуется, потому что длинные применения остаются в хребтовом применении. Это область для более умного встраивания.

\subsection{Сборка мусора}
Наша реализация использует простой двух-областный блокирующий сборщик мусора (Jones \& Lins, 1996). Хотя двух-областный сборщик не оптимален для использования в условиях ограниченной памяти, он имеет преимущество в простоте реализации. В частности, алгоритм легко определяется итеративно, поэтому не требуется наличия рекусривных стеков вызова. Смотри главу 6.3 для некоторых измерений производительности сборки мусора.

\subsection{Аппаратное описание}
Редуцерон полностью описан с помощью около 2,000 строк York Lava (Naylor et al., 2009), яызка описания аппаратуры, встроенного в Haskell. Большая часть описания относится к сборке мусора и битовому кодированию шаблонного кода; конкретные правила редукции занимают меньше чем 400 строк.

Описание Редуцерона сильно отличается от других опубликованных применений Lava. Оно совмещается \textit{структурное и поведеченское} стили описания. Поведенческое описание улучшает \textit{модульность}: мы связываем каждое правило редукции с транзакцией в памяти, которую оно производит, в отличии от связывания каждого модуля памяти со всеми транзакциями в памяти, которые совершаются в нем. Поэтому каждое правило редукции может быть описано независимо. 

Язык поведенческого описания, названный Recipe и включенный вместе с York Lava, имеет форму 300 строчной Lava библиотеки. Он предоставляет изменяемые переменные, выражения присваивания, последовательную и параллельную композицию, условные и циклические конструкции и разделенные вызовы процедур. Дополнительно, он использует результаты простотого временного анализа, реализованный абстрактной интерпретацией, для поддержки оптимизаций.

\subsection{Результаты синтеза}
Синтезирование нашей реализации для Xilinx Virtex-5 LX110T (класс скорости 1) приводит к FPGA проекту, использующему 14\% доступных логических элементов и 90\% доступных блоков RAM. Максимальная частота работы после разметки-разводки (place-and-route) составляет 96 MHz. Для сравнения, Xilinx распространяет вручную оптимизированный RISC мягкий микропроцессор, называемый MicroBlaze (Xilinx, 2009), который работает на частоте 210 MHz на той же FPGA. Так как Редуцерон производит очень много вычислений на один такт \textit{и не является конвеерным} (Microblaze имеет пять стадий конвеера), 96 MHz выгдялят прилично. Однако, в то время как Microblaze является 32х битным процессором, Редуцерон работает только с 18 битными атомами (18 бит достаточно для адресации всей кучи, хранящейся в блоках RAM); увеличение размера атомов до 32х бит может повлиять на максимальную частоту работы Редуцерона. Смотри главу 6.3 для сравнения производительности исполнения шаблонного кода Редуцероном и исполнения трационного скомпилированного кода на Microblaze.

\subsection{Оптимизации}
Эта глава описывает несколько оптимизаций, определенных как череда постепенных изменений семантики, определенной в главе 3. Тема это главы - использование \textit{дешевого динамического анализа} для улучшения производительности.

\subsection{Избегание обновлений}
Напомним, что когда вычисление применения в куче завершено, куча обновляется результатом, чтобы предотвратить повторных вычислений. Есть два случая, когда такое обновление нежелательно:
\begin{itemize}
\item Применение \textit{уже вычислено};
\item Применение \textit{не разделяется}, поэтому его результат больше никогда не будет использован.
\end{itemize}
В Редуцероне каждое обновление требует такта, поэтому избегание некоторых ненужных обновлений улучшит производительность.

Мы определяем неразделяемые приложения во \textit{время выполнения} с помощью \textit{динамического} анализа. Атомы аргумента и указателя расширены дополнительным логическим полем.
\begin{verbatim}
> data Atom = ... | ARG Bool Int | PTR Bool Int | ...
\end{verbatim}

Аргумент помечается True тогда и только тогда, когда он встречается более чем один раз в теле функции. Указатель помечается False тогда и только тогда, когда он является \textit{уникальный указателем}; то есть, он указывает на применение, на которое непосредственно не указывают другие атомы в куче или редукционном стеке. Может существовать множество указателей на применение, содержащее уникальный указатель, поэтому факт того, что указатель уникальный, само по себе, не достаточно, чтобы заключить, что он указывает на неразделяемое применение. Чтобы определить неразделяемые применения, мы придерживаемся следующего инварианта.

\begin{itemize}
\item \textbf{Инвариант 3.} Уникальный указатель, появляющийся на редукционном стеке указывает на неразделяемое применение.
\end{itemize}

Неуникальный указатель называют \textit{возможно разделяемым}.

\textbf{Размотка.} Правило редукции для размотки становится:
\begin{verbatim}
> step (p, h, PTR sh x:s, u) = (p, h, app++s, upd++u)
>   where
>     app = map (dashIf sh) (h!!x)
>     upd = [(1+length s, x) | sh && red (h!!x)]
\end{verbatim}

Если указатель на вершине стека возможно разделяемый, тогда применение помечается перед копированием на стек, помечая каждый его атом как возможно разделяемый. Это обеспечивает эффект распространения информации о разделеяемости через применение:

\begin{verbatim}
> dashIf sh a = if sh then dash a else a

> dash (PTR sh s) = PTR True s
> dash a = a
\end{verbatim}

Если указатель на вершине стека уникален, то применение, на которое он указывает, должно быть неразделяемым согласно Инварианту 3. Обновление проталкивается в стек обновленией только, если указатель возможно разделяемый и применение \textit{сводимое (reducible)}. Применение является сводимым, если оно насыщено или его первый атом является указателем.

\begin{verbatim}
> red :: App -> Bool
> red (PTR sh i:xs) = True
> red (x:xs) = arity x <= length xs
\end{verbatim} 

\textbf{Обновление.} Когда происходит обновление, в кучу записывается нормальная форма со стека. Эта нормальная форма может содержать уникальный указатель, но процесс записи формы в кучу сдублирует его. Следовательно нормальная форма на стеке помечается:
\begin{verbatim}
> step (p, h, top:s, (sa, ha):u)
>   | arity top > n = (p, h', top:dashN n s, u)
>   where
>     n = 1+length s - sa
>     h' = update ha (top:take n s) h

>  dashN n s = map dash (take n s) ++ drop n s
\end{verbatim}

Нет необходимости помечать нормальную форму, которая записывается в кучу, но это не нанесет вреда: это применение будет обновлено и возможно помечено, и возможно разделяемые применение будут в любом случае помечены при их размотки на стек. 

\textbf{Применение функции.} Когда происходит создание тела функции, разделяемые аргументы должны быть помечены по мере их выборки со стека:
\begin{verbatim}
> inst s base (PTR sh p) = PTR sh (base + P)
> inst s base (ARG sh i) = dashIf sh (s!!i)
> inst s base a = a
\end{verbatim}

\textbf{Производительнсоть.} Таблицы~\ref{tab:clock-cycle_optimisations} и~\ref{tab:heap_optimisations} показывают, что избегание обновлений приводят к значительному улучшению производительности во время выполнения. В среднем 88\% всех обновленией избегаются среди 16 тестовых программ. Чуть более половины из них избегаются из-за несводимых применений, и чуть меньше половины из них избегаются из-за неразделяемых сводимых применений. Средний максимум использования стека обновления снизился с 406 до 11.

Динамический анализ разделяемости не идеален. Некоторые возможности для избегания обновлений упущены, когда указатаель копируется во время выполнения, но копия отбрасывается до того, как применение, на которое указывает указатель, непосредственно вычисляется. Полноценный сборщик мусора с подсчетом сылок позволит собирать даже более точную информацию о разделяемости.

\subsection{Инфиксные примитивные применения}
Рассмотрим шаги, необходимые для вычисления применения $(+) \; e_0 \; e_1$.  Используя подход редукции примитивов в главе 3.1, применение во время компиляции трансформируется в $e_1 \; (e_0 \; (+))$. Во время выполнения необходимо произвести как минимум следующие шаги:
\begin{enumerate}
\item Редукция челочисленного значения требуется после вычисления $e_1$ (для выполнения правила трансформации (2), определенного в главе 3.1).
\item Редукция размоткри требуется для получения применения $e_0 \; (+)$ из кучи.
\item Вторая редукция челочисленного значения требуется полсе вычисления $e_0$.
\item Необходима примитивная редукция для применения (+) к двум вычисленным аргументам.
\end{enumerate}

Необходимость выполнения этих четырех шагов для каждого примитивного применения довольно дорога. В этой главе, мы предлагаем новый метод для обработки примитивных применений, который не приводит к такому количеству шагов редукции.

\textbf{Новый метод.} Для каждой бинарной примитивной функции $p$, мы вводим новый примитив $*p$, версию $p$, которая ожидает переставленные местами аргументы:
\begin{verbatim}
> prim ('*':p) n m = prim p m n
\end{verbatim}

Каждая примитивная функция может быть обращена таким образом:
\begin{verbatim}
> flip ('*':p) = p
> flip p = '*':p
\end{verbatim}

Теперь мы преобразуем бинарные примитивные применения с помощью правила:
\begin{equation}\label{eq:rule_optimised_prim}
p \; m \; n \rightarrow m \; p \; n
\end{equation}

Вместо существующих правил редукции для примитивов и целочисленных констант мы определяем:
\begin{verbatim}
> step (p, h, INT m:PRI f:INT n:s, u) = 
>   (p, h, prim f m n:s, u)
> step (p, h, INT m:PRI f:x:s, u) =
>   (p, h, x:PRI (flip f):INT m:s, u)
\end{verbatim}

Если оба аргумента уже вычислены, то примитивная функция применяется. Если вычислен только первый аргумент, то аргументы меняются местами и примитив обращается (flip).

Заметим, что правило компиляции (\ref{eq:rule_optimised_prim}) разумно может быть формы:
\begin{equation} \label{eq:rule_alt_optimised_prim}
p \; m \; n \rightarrow n \; *p \; m
\end{equation}

В целях эффективности выбор между (\ref{eq:rule_optimised_prim}) и (\ref{eq:rule_alt_optimised_prim}) производится для каждого примитивного применения с помощью информации, полученной во время компиляции, о том, которых из m или n ожидается вычисленным первым.

\textbf{Пример.} Примитивное применение формы $(+) \; e_0 \; e_1$ теперь трансформируется в $e_0 \; (+) \; e_1$ во время компиляции. Во время выполнения требуются только следующие операции:
\begin{enumerate}
\item Редукция целочисленной константы необходима после вычилсения $e_0$.
\item Редукция примитива необходима после вычисления $e_1$.
\end{enumerate}

На каждое примитивное применение было сохранено два редукционных шага. Также заметим, что $e_0 \; (+) \; e_1$ содержит одно пименение, когда $e_1 (e_0 \; (+))$ содержит два, поэтому первое дешевле создавать.

\textbf{Результаты.} Таблицы~\ref{tab:clock-cycle_optimisations} и~\ref{tab:heap_optimisations} показывают улучшения производительности во время выполнения и использования кучи, полученные при новом подходе.

\subsection{Предсказательное вычисление примитивных выражений}

\end{document}